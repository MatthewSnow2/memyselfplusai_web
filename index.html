<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Me, Myself Plus AI is a boutique AI studio in Nashville creating custom autonomous-agent solutions for small-to-mid-size businesses." />
  <meta name="keywords" content="AI, autonomous agents, automation, consulting, training, Nashville, small business, Me Myself Plus AI, agentic systems" />
  <meta name="author" content="Me, Myself Plus AI" />
  <meta property="og:title" content="Me, Myself Plus AI | Focus on What Matters Most" />
  <meta property="og:description" content="Empowering Individuals by Making AI Integration Accessible and Simple. Boutique AI studio in Nashville." />
  <meta property="og:image" content="public/images/FullLogo_Transparent_NoBuffer.png" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://www.yourdomain.com/" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Me, Myself Plus AI" />
  <meta name="twitter:description" content="Boutique AI studio in Nashville offering custom agentic automation." />
  <meta name="twitter:image" content="public/images/FullLogo_Transparent_NoBuffer.png" />
  <title>Me, Myself Plus AI | Focus on What Matters Most</title>
  <link rel="icon" type="image/png" href="public/images/FullLogo_Transparent_NoBuffer.png" />
  <link rel="stylesheet" href="public/css/navigation.css">
  <link rel="stylesheet" href="public/css/main.css">
  <link rel="stylesheet" href="public/css/index.css">
  <link rel="stylesheet" href="public/css/audit-modal.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@3.4.1/dist/tailwind.min.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=Roboto+Mono&display=swap" rel="stylesheet">
  <!-- Styles moved to external CSS files -->
</head>
<body>
  <canvas id="bg-canvas"></canvas>
  
  <!-- Fixed navigation header using classes from external CSS -->  
  <div class="header-nav-container">
    <nav class="header-nav">
      <a href="index.html" class="nav-link-current">Home</a>
      <a href="about.html" class="nav-link-default">Voice Agents</a>
      <a href="services.html" class="nav-link-default">Automations</a>
      <a href="projects.html" class="nav-link-default">Projects</a>
      <a href="blog/index.html" class="nav-link-default">Resources</a>
      <a href="contact.html" class="nav-link-default">Contact</a>
    </nav>
  </div>
  
  <div class="main-content">
    <img src="public/images/FullLogo_Transparent_NoBuffer.png" alt="Me Myself Plus AI Logo" class="logo" />
    <div class="headline">Cutting-Edge AI Solutions for Visionary Leaders</div>
    <div class="audit-cta-container">
      <button onclick="openAuditModal()" class="cta-button-orange">Self-Serve AI Audit</button>
    </div>
    <div class="cta-container">
      <a href="contact.html" class="cta-button">Contact Us</a>
    </div>
  </div>
  
  <!-- Popular Services Section -->
  <div class="services-overview">
    <div class="section-header">
      <h2 class="section-title">Popular AI Solutions</h2>
      <p class="section-subtitle">Simple, powerful tools to transform your business</p>
    </div>
    
    <div class="services-grid">
      <!-- Chatbots -->
      <div class="service-overview-card">
        <div class="service-icon">üí¨</div>
        <h3 class="service-overview-title">Chatbots</h3>
        <p class="service-overview-description">
          Smart chat assistants that handle customer questions, book appointments, and provide support 24/7. 
          Like having a helpful team member who never sleeps.
        </p>
      </div>
      
      <!-- Voice Agents -->
      <div class="service-overview-card">
        <div class="service-icon">üéôÔ∏è</div>
        <h3 class="service-overview-title">Voice Agents</h3>
        <p class="service-overview-description">
          AI assistants that can answer phone calls, schedule appointments, and handle customer inquiries through natural conversation. 
          Perfect for busy businesses that need extra hands.
        </p>
      </div>
      
      <!-- Custom GPTs -->
      <div class="service-overview-card">
        <div class="service-icon">üß†</div>
        <h3 class="service-overview-title">Custom GPTs</h3>
        <p class="service-overview-description">
          Personalized AI assistants trained specifically for your business needs. 
          Think of them as digital experts who know your company inside and out.
        </p>
      </div>
      
      <!-- Automations -->
      <div class="service-overview-card">
        <div class="service-icon">‚ö°</div>
        <h3 class="service-overview-title">Automations</h3>
        <p class="service-overview-description">
          Smart workflows that handle repetitive tasks like invoicing, scheduling, and data entry. 
          Free up your time for what matters most.
        </p>
      </div>
      
      <!-- Web Apps -->
      <div class="service-overview-card">
        <div class="service-icon">üåê</div>
        <h3 class="service-overview-title">Web Apps</h3>
        <p class="service-overview-description">
          Custom web applications tailored to your business processes. 
          Easy-to-use tools that help your team work more efficiently.
        </p>
      </div>
      
      <!-- Custom AI Assistants -->
      <div class="service-overview-card">
        <div class="service-icon">ü§ñ</div>
        <h3 class="service-overview-title">Custom AI Assistants</h3>
        <p class="service-overview-description">
          Specialized AI helpers designed for your specific industry and challenges. 
          Like hiring a consultant who's available anytime you need them.
        </p>
      </div>
    </div>
    
    <div class="services-cta">
      <a href="services.html" class="cta-button">Explore All Solutions</a>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('bg-canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let time = 0;
    
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    
    window.addEventListener('resize', resize);
    resize();
    
    // Neural network nodes and connections
    let nodes = [];
    let connections = [];
    let signals = [];
    
    function initializeNetwork() {
      nodes = [];
      connections = [];
      signals = [];
      
      // Create layers of nodes
      const layers = [6, 8, 10, 8, 6]; // Input, hidden layers, output
      const layerSpacing = width / (layers.length + 1);
      
      let nodeId = 0;
      for (let l = 0; l < layers.length; l++) {
        const nodesInLayer = layers[l];
        const nodeSpacing = height / (nodesInLayer + 1);
        
        for (let n = 0; n < nodesInLayer; n++) {
          nodes.push({
            id: nodeId++,
            x: layerSpacing * (l + 1),
            y: nodeSpacing * (n + 1),
            layer: l,
            activation: Math.random(),
            pulsePhase: Math.random() * Math.PI * 2,
            size: 4 + Math.random() * 3
          });
        }
      }
      
      // Create connections between adjacent layers
      for (let l = 0; l < layers.length - 1; l++) {
        const currentLayer = nodes.filter(n => n.layer === l);
        const nextLayer = nodes.filter(n => n.layer === l + 1);
        
        currentLayer.forEach(fromNode => {
          nextLayer.forEach(toNode => {
            if (Math.random() > 0.3) { // 70% chance of connection
              connections.push({
                from: fromNode,
                to: toNode,
                weight: Math.random() * 2 - 1, // -1 to 1
                lastSignal: 0
              });
            }
          });
        });
      }
    }
    
    function drawBackground() {
      // Create gradient background
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, '#0f172a'); // Dark slate
      gradient.addColorStop(0.3, '#1e293b'); // Slate 800
      gradient.addColorStop(0.7, '#0891b2'); // Cyan 600
      gradient.addColorStop(1, '#164e63'); // Cyan 800
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }
    
    function updateNetwork() {
      // Update node activations with pulsing effect
      nodes.forEach(node => {
        node.activation = 0.3 + 0.7 * (Math.sin(time * 0.01 + node.pulsePhase) + 1) / 2;
      });
      
      // Create new signals randomly
      if (Math.random() < 0.02) {
        const inputNodes = nodes.filter(n => n.layer === 0);
        const startNode = inputNodes[Math.floor(Math.random() * inputNodes.length)];
        
        signals.push({
          currentNode: startNode,
          progress: 0,
          path: [],
          intensity: 0.8 + Math.random() * 0.2
        });
      }
      
      // Update signals
      signals.forEach((signal, index) => {
        signal.progress += 0.02;
        
        if (signal.progress >= 1) {
          // Signal reached destination, find next connection
          const availableConnections = connections.filter(c => c.from === signal.currentNode);
          
          if (availableConnections.length > 0 && signal.currentNode.layer < 4) {
            const nextConnection = availableConnections[Math.floor(Math.random() * availableConnections.length)];
            signal.currentNode = nextConnection.to;
            signal.progress = 0;
            nextConnection.lastSignal = time;
          } else {
            // Remove signal if it reached the end
            signals.splice(index, 1);
          }
        }
      });
      
      // Clean up old signals
      signals = signals.filter(s => s.intensity > 0.1);
    }
    
    function drawNetwork() {
      // Draw connections
      connections.forEach(conn => {
        const timeSinceSignal = time - conn.lastSignal;
        const recentSignal = timeSinceSignal < 30;
        
        ctx.strokeStyle = recentSignal 
          ? `rgba(6, 182, 212, ${0.8 - timeSinceSignal / 30})` 
          : 'rgba(6, 182, 212, 0.15)';
        ctx.lineWidth = recentSignal ? 2 : 1;
        
        ctx.beginPath();
        ctx.moveTo(conn.from.x, conn.from.y);
        ctx.lineTo(conn.to.x, conn.to.y);
        ctx.stroke();
      });
      
      // Draw nodes
      nodes.forEach(node => {
        const intensity = node.activation;
        const size = node.size * (0.8 + intensity * 0.4);
        
        // Node glow
        const gradient = ctx.createRadialGradient(node.x, node.y, 0, node.x, node.y, size * 2);
        gradient.addColorStop(0, `rgba(6, 182, 212, ${intensity * 0.8})`);
        gradient.addColorStop(0.5, `rgba(6, 182, 212, ${intensity * 0.4})`);
        gradient.addColorStop(1, 'rgba(6, 182, 212, 0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(node.x, node.y, size * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Node core
        ctx.fillStyle = `rgba(6, 182, 212, ${0.6 + intensity * 0.4})`;
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Draw signals
      signals.forEach(signal => {
        const availableConnections = connections.filter(c => c.from === signal.currentNode);
        
        if (availableConnections.length > 0) {
          availableConnections.forEach(conn => {
            const x = conn.from.x + (conn.to.x - conn.from.x) * signal.progress;
            const y = conn.from.y + (conn.to.y - conn.from.y) * signal.progress;
            
            // Signal particle
            ctx.fillStyle = `rgba(255, 255, 255, ${signal.intensity})`;
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Signal trail
            const trailLength = 20;
            for (let i = 1; i <= trailLength; i++) {
              const trailProgress = Math.max(0, signal.progress - i * 0.02);
              const trailX = conn.from.x + (conn.to.x - conn.from.x) * trailProgress;
              const trailY = conn.from.y + (conn.to.y - conn.from.y) * trailProgress;
              const trailAlpha = signal.intensity * (1 - i / trailLength) * 0.5;
              
              ctx.fillStyle = `rgba(6, 182, 212, ${trailAlpha})`;
              ctx.beginPath();
              ctx.arc(trailX, trailY, 2 * (1 - i / trailLength), 0, Math.PI * 2);
              ctx.fill();
            }
          });
        }
      });
    }
    
    function animate() {
      time += 1;
      
      drawBackground();
      updateNetwork();
      drawNetwork();
      
      requestAnimationFrame(animate);
    }
    
    // Initialize network when page loads and on resize
    function handleResize() {
      resize();
      initializeNetwork();
    }
    
    window.removeEventListener('resize', resize);
    window.addEventListener('resize', handleResize);
    
    initializeNetwork();
    animate();
  </script>
  <script src="public/js/audit-modal.js"></script>
</body>
</html>
